## UserVault – User API with DOB and Calculated Age

UserVault is a small Go project that exposes a REST API to manage users and their date of birth.  
The idea is simple:

- Store each user’s **name** and **dob** (date of birth) in PostgreSQL.
- When you read users back, **calculate their age on the fly** using Go’s `time` package instead of storing it.

This README is written so you can explain the project confidently in an interview: what it does, how it’s structured, and why certain tools were chosen.

---

## 1. What the project does (high level)

- **Core entity**: `User`
  - `id` – auto‑incrementing primary key
  - `name` – string
  - `dob` – `DATE` in PostgreSQL
- **API operations**:
  - `POST /users` – create a user
  - `GET /users/:id` – get one user (includes `age`)
  - `PUT /users/:id` – update a user
  - `DELETE /users/:id` – delete a user
  - `GET /users` – list all users (with pagination, includes `age`)
- **Age calculation**:
  - Age is **not stored in the DB**.
  - It’s calculated every time from `dob` and `time.Now()` using a small helper function.

From an interviewer’s perspective, this shows:

- Understanding of basic CRUD APIs.
- Clean separation between storage (`dob`) and derived data (`age`).
- Reasonable backend structure (handlers → services → repository → DB).

---

## 2. Tech stack and why I used it

- **Go + Go modules**
  - Strongly typed, fast, great for backend services.
- **GoFiber**
  - A lightweight, fast web framework inspired by Express.js.
  - Makes routing and middleware simple, but still stays close to the standard library style.
- **PostgreSQL**
  - Mature relational database; `DATE` type fits perfectly for `dob`.
- **SQLC**
  - Generates type‑safe Go code from raw SQL.
  - Lets me:
    - Write SQL by hand (full control).
    - Get strongly typed Go functions and models for queries.
  - This shows that I can balance convenience and control (vs a heavy ORM).
- **pgx / pgxpool**
  - PostgreSQL driver and connection pool that integrates nicely with SQLC.
  - Used via `pgxpool.Pool`, which implements the `DBTX` interface generated by SQLC.
- **go-playground/validator**
  - Popular validation library in Go.
  - Used to validate incoming JSON (e.g. name not empty, dob has correct format).
- **Uber Zap**
  - Structured logging with good performance.
  - Used to log requests, errors, and startup information in a machine‑readable way.

These choices show that you know:

- How to pick tools commonly used in real Go services.
- How to wire them together cleanly.

---

## 3. Project structure and what each part does

```text
cmd/server/main.go        # Application entry point

config/                   # Configuration (env variables, ports, DB URL)
  config.go

db/
  migrations/             # SQL migrations to build the DB schema
    001_create_users.sql
  sqlc/                   # SQLC-generated DB layer
    db.go
    models.go
    queries/users.sql     # Source queries
    users.sql.go          # Generated Go code for queries

internal/
  models/                 # Domain models + age calculation + tests
    user.go
    user_test.go
  repository/             # Data access layer (wraps SQLC)
    user_repository.go
  service/                # Business logic (validation, age calculation)
    user_service.go
  handler/                # HTTP handlers (Fiber)
    user_handler.go
  routes/                 # Route registration
    routes.go
  middleware/             # Cross-cutting concerns (logging)
    logger.go
  logger/                 # Zap logger initialization
    logger.go
```

### 3.1 `cmd/server/main.go` – where everything is wired together

This is the starting point of the app. It does:

- Load configuration (port + DB URL) from `config`.
- Create a Zap logger.
- Create a `pgxpool.Pool` using the `DATABASE_URL`.
- Ping the DB to make sure it’s reachable.
- Create a Fiber app.
- Attach logging middleware.
- Initialize:
  - `UserRepository` (DB access).
  - `UserService` (business logic, validation, age calculation).
  - `UserHandler` (HTTP handlers).
- Register all routes.
- Start listening on the configured port.

If asked in an interview:  
“**main.go is responsible for wiring together the infrastructure (DB, logger, router) and the application layers (repository, service, handler).**”

### 3.2 `config/` – configuration

- `config.go` reads:
  - `PORT` (defaults to `8080`).
  - `DATABASE_URL` (defaults to `postgres://localhost:5432/uservault?sslmode=disable`).

This shows you understand 12‑factor style config via environment variables.

### 3.3 `db/migrations` – database schema

- `001_create_users.sql`:
  - Creates a `users` table with:
    - `id SERIAL PRIMARY KEY`
    - `name TEXT NOT NULL`
    - `dob DATE NOT NULL`
    - `created_at`, `updated_at` timestamps

You can say:  
“**I manage schema using SQL migrations so the DB structure is versioned and reproducible.**”

### 3.4 `db/sqlc` – SQLC generated code

- `queries/users.sql` contains the SQL queries:
  - `CreateUser`, `GetUser`, `ListUsers`, `UpdateUser`, `DeleteUser`.
- `sqlc.yaml` tells SQLC:
  - Where the schema and queries live.
  - To generate Go code into `db/sqlc` with the package name `sqlcdb`.

When you run `sqlc generate`, it creates:

- `db.go` with the `DBTX` interface and `Queries` struct.
- `models.go` with the `User` model (using `pgtype.Date` etc).
- `users.sql.go` with CRUD functions.

This means:

> “**I write SQL once, then SQLC generates type‑safe Go wrappers so I don’t have to manually scan rows.**”

### 3.5 `internal/repository` – repository layer

File: `user_repository.go`

- Defines a `UserRepository` interface with methods:
  - `Create`, `Get`, `List`, `Update`, `Delete`.
- Concrete implementation wraps SQLC’s `Queries`:
  - Accepts a `sqlcdb.DBTX` (in practice a `*pgxpool.Pool`).
  - Converts Go `time.Time` to `pgtype.Date`.
  - Converts IDs between `int64` (service/API) and `int32` (DB).

You can explain it as:

> “**The repository isolates database details and SQLC-specific types. The rest of the app talks to an interface, which makes it easier to change the DB or mock it later.**”

### 3.6 `internal/models` – domain model and age calculation

File: `user.go`

- Defines the API-facing `User` struct:
  - `ID`, `Name`, `DOB` (as `YYYY-MM-DD` string), `Age` (computed).
- Request DTOs:
  - `CreateUserRequest` and `UpdateUserRequest`, with validation tags.
- `CalculateAge(dob, now time.Time)`:
  - Computes age in full years.
  - Subtracts one year if the birthday hasn’t occurred yet this year.
  - Returns 0 for future `dob`.

File: `user_test.go`

- Unit tests for `CalculateAge`:
  - Covers:
    - Birthday already passed this year.
    - Birthday today.
    - Birthday not yet reached this year.
    - DOB in the future.

This is great to mention:

> “**I wrote small unit tests around the age calculation to make sure edge cases are correct, which also demonstrates that I can test pure logic separately from HTTP or DB.**”

### 3.7 `internal/service` – business logic

File: `user_service.go`

Responsibility:

- Validate input using `go-playground/validator`.
- Parse `dob` strings into `time.Time`.
- Call the repository to do DB operations.
- Convert DB models (`sqlcdb.User`) to API models (`models.User`).
- Compute `age` using `CalculateAge`.

For example:

- `CreateUser`:
  - Validates the request.
  - Parses `dob` (format `2006-01-02`).
  - Calls `repo.Create`.
  - Builds the response user with `Age` calculated from `dob`.

You can say:

> “**The service layer is where the actual rules live: validation, parsing dates, calculating age, and orchestrating repository calls. Handlers stay thin and just deal with HTTP details.**”

### 3.8 `internal/handler` – HTTP handlers (Fiber)

File: `user_handler.go`

Implements the actual endpoints:

- `POST /users`
- `GET /users/:id`
- `PUT /users/:id`
- `DELETE /users/:id`
- `GET /users` (with `limit` and `offset` for pagination)

Each handler:

- Parses path params or query params.
- Parses JSON body (for create/update).
- Calls the service.
- Returns proper HTTP status codes and JSON responses.
- On error, logs with Zap and returns a clean error message.

This is the “controller”/“transport” layer.

### 3.9 `internal/routes` – route registration

File: `routes.go`

- Binds HTTP methods + paths to handler methods on the Fiber app.
- Keeps `main.go` clean by hiding route setup in one place.

### 3.10 `internal/middleware` + `internal/logger`

- `internal/logger/logger.go`:
  - Creates a production Zap logger.
- `internal/middleware/logger.go`:
  - Fiber middleware that logs:
    - HTTP method.
    - Path.
    - Status code.
    - Duration of the request.

You can explain:

> “**I added a basic logging middleware using Zap so every request is logged with structured fields, which is handy for debugging and monitoring.**”

---

## 4. How to run the project

Assuming:

- Go is installed.
- PostgreSQL is installed (e.g. via Homebrew on macOS).

From the project root: `~/WebDev/JavaScript/UserVault`

### 4.1 Start PostgreSQL (if it’s not already running)

```bash
brew services start postgresql@14
```

### 4.2 Create the database and run migrations

```bash
createdb uservault
psql uservault < db/migrations/001_create_users.sql
```

### 4.3 Set environment variables (optional but recommended)

```bash
export DATABASE_URL="postgres://localhost:5432/uservault?sslmode=disable"
export PORT=8080  # optional, defaults to 8080
```

### 4.4 Install Go dependencies

```bash
go get github.com/gofiber/fiber/v2 \
       github.com/jackc/pgx/v5/pgxpool \
       github.com/jackc/pgx/v5 \
       github.com/jackc/pgconn \
       go.uber.org/zap \
       github.com/go-playground/validator/v10 \
       github.com/jmoiron/sqlx
```

### 4.5 Install and run SQLC

Install (pick one):

- Homebrew:

  ```bash
  brew install sqlc
  ```

- Or via Go:

  ```bash
  go install github.com/sqlc-dev/sqlc/cmd/sqlc@latest
  export PATH="$PATH:$(go env GOPATH)/bin"
  ```

Generate the code:

```bash
sqlc generate
```

### 4.6 Run tests for the age calculation (bonus)

```bash
go test ./internal/models
```

### 4.7 Run the server

```bash
go run ./cmd/server
```

The API should now be listening on `http://localhost:8080`.

---

## 5. How to test the API

Here are some `curl` examples you can use (or replicate in Postman/Insomnia).

### 5.1 Create a user

```bash
curl -X POST http://localhost:8080/users \
  -H "Content-Type: application/json" \
  -d '{"name":"Alice","dob":"1990-05-10"}'
```

Expected response:

```json
{
  "id": 1,
  "name": "Alice",
  "dob": "1990-05-10"
}
```

### 5.2 Get a user (with age)

```bash
curl http://localhost:8080/users/1
```

Expected response (age will depend on current date):

```json
{
  "id": 1,
  "name": "Alice",
  "dob": "1990-05-10",
  "age": 35
}
```

### 5.3 Update a user

```bash
curl -X PUT http://localhost:8080/users/1 \
  -H "Content-Type: application/json" \
  -d '{"name":"Alice Updated","dob":"1991-03-15"}'
```

Expected response:

```json
{
  "id": 1,
  "name": "Alice Updated",
  "dob": "1991-03-15"
}
```

### 5.4 List users (with pagination)

```bash
curl "http://localhost:8080/users?limit=10&offset=0"
```

Example response:

```json
[
  {
    "id": 1,
    "name": "Alice Updated",
    "dob": "1991-03-15",
    "age": 34
  }
]
```

### 5.5 Delete a user

```bash
curl -X DELETE http://localhost:8080/users/1 -i
```

Look for:

```text
HTTP/1.1 204 No Content
```

---

## 6. How to explain this project in an interview

Here is a short script you can adapt:

> “I built a small REST API in Go called UserVault. It manages users in a PostgreSQL database, storing their name and date of birth. The interesting part is that the age is not stored — it’s calculated dynamically in Go using the `time` package every time you fetch a user or list users.
>
> I structured the code into clear layers: handlers (HTTP with GoFiber), services (business logic, including validation and age calculation), and repositories (data access using SQLC-generated code). SQLC lets me write raw SQL but still get type-safe Go functions for each query. I also used Uber Zap for structured logging and go-playground/validator to validate incoming JSON payloads.
>
> The project has a simple migration-based schema for the `users` table, pagination support on the list endpoint, and unit tests around the age calculation to cover edge cases like birthdays that haven’t happened yet this year. Overall, it’s a compact but realistic example of how I’d structure a small Go service in production.” 

You can tweak the wording to sound natural for you, but this covers:

- What the project does.
- How it’s structured.
- Why you chose each major tool.
- A small example of testing and validation.



